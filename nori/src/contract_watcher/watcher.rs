use anyhow::{Context, Result};
use ethers::{prelude::*, providers::{Ws,Http}};
use std::{env, sync::Arc};
use tokio::sync::mpsc;

// Generate contract bindings from ABI
abigen!(
    NoriTokenBridge,
    "nori-contracts/artifacts/contracts/NoriTokenBridge.sol/NoriTokenBridge.json",
    event_derives (serde::Deserialize, serde::Serialize);
);
/* 
#[derive(Debug, Clone, EthEvent)]
pub struct TokensLocked {
    #[ethevent(indexed)]
    pub user: Address,
    pub amount: U256,
    pub when: U256,
    pub new_value: U256,
}*/
/*
pub async fn get_source_contract_events_between_blocks(
    eth_http_rpc: &String,
    token_bridge_address: &Address,
    start_block: u64,
    end_block: u64,
) -> Result<()> {
    let provider = Provider::<Http>::try_from(eth_http_rpc)?;
    let provider = Arc::new(provider);
    let contract = NoriTokenBridge::new(*token_bridge_address, provider.clone());

    let contract_locked_event = contract.event::<TokensLockedFilter>();



    //let x = contract.event::<TokensLockedFilter>();
    //x.watcher();

    // Query the events directly using the event name from the contract
    //contract.tokens_locked_filter();



    //let a = contract.events().query().await;
    
    /*let events = contract
        .event::<TokensLockedFilter>() // Use our defined event filter type
        .from_block(start_block)
        .to_block(end_block)
        .query()
        .await?;*/

    /*let events = contract
    .events()
    .from_block(start_block)
    .to_block(end_block)
    .topic::<TokensLocked>() // Use the TokensLocked event type generated by abigen!
    .query()
    .await?;*/

    // Convert to Vec<TokensLocked>
    //events.into_iter().map(|event| event.data).collect();

    /*let _ = contract
    .event::<TokensLockedFilter>()
    .from_block(start_block)
    .to_block(end_block)
    .query()
    .await
    .map(|events| events.into_iter().map(|(e, _)| e).collect());*/

    /*let event = contract
    .event::<TokensLockedFilter>()
    .from_block(start_block)
    .to_block(end_block)
    .query();*/

    //event.watcher();

    /* .from_block(start_block)
    .to_block(end_block);*/

    /*let logs = event
    .query()
    .await?
    .into_iter()
    .map(|(event, _log)| event) // Strip out raw log if needed
    .collect();*/

    Ok(())
}
*/
pub async fn get_source_contract_listener(
) -> Result<mpsc::Receiver<Result<TokensLockedFilter, anyhow::Error>>> {
    dotenv::dotenv().ok();

    // Validate everything upfront
    let eth_ws_rpc =
        env::var("NORI_ETH_WS_RPC").context("Missing NORI_ETH_WS_RPC in environment")?;

    let token_bridge_address = env::var("NORI_TOKEN_BRIDGE_ADDRESS")
        .context("Missing NORI_TOKEN_BRIDGE_ADDRESS in environment")?
        .parse::<Address>()
        .context("Invalid Ethereum address format")?;

    let provider = Provider::<Ws>::connect(&eth_ws_rpc)
        .await
        .context("Failed to connect to WebSocket provider")?;
    let provider = Arc::new(provider);

    let contract = NoriTokenBridge::new(token_bridge_address, provider.clone());

    // Contract locked events
    let contract_locked_event = contract.event::<TokensLockedFilter>();

    // Create channel after successful validation
    let (tx, rx) = mpsc::channel(32);

    // Spawn task for event handling
    tokio::spawn(async move {
        let mut stream = match contract_locked_event.subscribe().await {
            Ok(s) => s,
            Err(e) => {
                let _ = tx.send(Err(e.into())).await;
                return;
            }
        };

        while let Some(event) = stream.next().await {
            let result = tx
                .send(event.map_err(|e| anyhow::anyhow!("Event error: {}", e)))
                .await;

            if result.is_err() {
                break; // Receiver dropped
            }
        }
    });

    Ok(rx)
}
